package handlers

import (
	"cs2-demo-service/models"
	"fmt"

	"github.com/markus-wa/demoinfocs-golang/v4/pkg/demoinfocs/events"
)

// RegisterCombatHandlers registra handlers para eventos de combate
func RegisterCombatHandlers(ctx *models.DemoContext) {
	// Kill events
	ctx.Parser.RegisterEventHandler(func(e events.Kill) {
		if e.Killer == nil || e.Victim == nil {
			return
		}

		killEvent := models.KillEvent{
			Tick:          ctx.Parser.GameState().IngameTick(),
			Round:         ctx.CurrentRound,
			Killer:        e.Killer.Name,
			KillerSteamID: e.Killer.SteamID64,
			Victim:        e.Victim.Name,
			VictimSteamID: e.Victim.SteamID64,
			Weapon:        e.Weapon.String(),
			IsHeadshot:    e.IsHeadshot,
			IsWallbang:    e.IsWallBang(),
			AttackerBlind: e.AttackerBlind,
			NoScope:       e.NoScope,
			ThroughSmoke:  e.ThroughSmoke,
			Distance:      e.Distance,
			KillerX:       float64(e.Killer.Position().X),
			KillerY:       float64(e.Killer.Position().Y),
			KillerZ:       float64(e.Killer.Position().Z),
			VictimX:       float64(e.Victim.Position().X),
			VictimY:       float64(e.Victim.Position().Y),
			VictimZ:       float64(e.Victim.Position().Z),
		}

		if e.Assister != nil {
			killEvent.Assister = e.Assister.Name
			killEvent.AssisterSteamID = e.Assister.SteamID64
		}

		// Attach Mechanics Data if available (within last 100 ticks ~800ms)
		if mech, ok := ctx.LastShotMechanics[e.Killer.SteamID64]; ok {
			if ctx.Parser.GameState().IngameTick() - mech.Tick < 100 {
				killEvent.CounterStrafeRating = mech.CounterStrafeRating
				killEvent.RecoilControlRating = mech.RecoilControlRating
			}
		}

		ctx.MatchData.Kills = append(ctx.MatchData.Kills, killEvent)

		// ADD TO TIMELINE
		AddKillToTimeline(ctx, ctx.Parser.GameState().IngameTick(), &killEvent)
	})

	// Player hurt events
	ctx.Parser.RegisterEventHandler(func(e events.PlayerHurt) {
		if e.Player == nil || e.Attacker == nil {
			return
		}

		damageEvent := models.DamageEvent{
			Tick:         ctx.Parser.GameState().IngameTick(),
			Round:        ctx.CurrentRound,
			Attacker:     e.Attacker.Name,
			Victim:       e.Player.Name,
			Weapon:       e.Weapon.String(),
			HealthDamage: e.HealthDamage,
			ArmorDamage:  e.ArmorDamage,
			HitGroup:     fmt.Sprintf("%v", e.HitGroup),
			VictimHealth: e.Health,
		}

		// Attach Mechanics Data if available (within last 100 ticks)
		if mech, ok := ctx.LastShotMechanics[e.Attacker.SteamID64]; ok {
			if ctx.Parser.GameState().IngameTick() - mech.Tick < 100 {
				damageEvent.CounterStrafeRating = mech.CounterStrafeRating
				damageEvent.RecoilControlRating = mech.RecoilControlRating
			}
		}

		ctx.MatchData.Damage = append(ctx.MatchData.Damage, damageEvent)

		// ADD TO TIMELINE
		AddDamageToTimeline(ctx, ctx.Parser.GameState().IngameTick(), &damageEvent)
	})

	// Weapon fire events (para spray analysis)
	ctx.Parser.RegisterEventHandler(func(e events.WeaponFire) {
		if e.Shooter == nil {
			return
		}

		sid := e.Shooter.SteamID64
		currentTick := ctx.Parser.GameState().IngameTick()

		// Track para spray detection
		ctx.LastWeaponFireTick[sid] = currentTick
	})
}
